<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【笔记】关于Android Studio混淆打包]]></title>
    <url>%2F2017%2F08%2F09%2F%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%B3%E4%BA%8EAndroid-Studio%E6%B7%B7%E6%B7%86%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[混淆首先修改app下的build.gradle文件 123456789101112131415161718192021//执行lint检查，有任何的错误或者警告提示，都会终止构建，我们可以将其关掉。lintOptions &#123; abortOnError false&#125; buildTypes &#123; release &#123; // 不显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot; //混淆 minifyEnabled true //Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true //前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125;&#125; 混淆模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207# 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5# 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames# 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses# 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose# 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify# 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/*############################################### Android开发中一些需要保留的公共部分############################################### 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125; # 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** # 保留R下面的资源-keep class **.R$* &#123;*;&#125; # 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; # 保留在Activity中的方法参数是view的方法， # 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125; # 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; # 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; # 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; # 保留Serializable序列化的类不被混淆-keepnames class * implements java.io.Serializable-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125; # webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; # 移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用 # 记得proguard-android.txt中一定不要加-dontoptimize才起作用 # 另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制 #-assumenosideeffects class android.util.Log &#123; # public static int v(...); # public static int i(...); # public static int w(...); # public static int d(...); # public static int e(...); #&#125;############################################## # 项目中特殊处理部分############################################## #-----------处理反射类--------------- #-----------处理js交互--------------- #-----------处理实体类--------------- # 在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。-keep class com.jkinfo.model.beans.**&#123; *; &#125; #-----------处理第三方依赖库----------keep class com.google.gson.**&#123;*;&#125;-keep class org.hamcrest.**&#123;*;&#125;-keep class com.squareup.javawriter.**&#123;*;&#125;-keep class com.squareup.picasso.**&#123;*;&#125;-keep class me.nereo.multi_image_selector.**&#123;*;&#125;-keep class okhttp3.**&#123;*;&#125;-keep class com.squareup.okhttp.**&#123;*;&#125;-keep class com.squareup.picasso.**&#123;*;&#125;-keep class com.google.zxing.**&#123;*;&#125;-keep class com.uuzuche.lib_zxing.**&#123;*;&#125; #---------------友盟提供--------------dontwarn com.taobao.**-dontwarn anet.channel.**-dontwarn anetwork.channel.**-dontwarn org.android.**-dontwarn org.apache.thrift.**-dontwarn com.xiaomi.**-dontwarn com.huawei.**-keepattributes *Annotation*-keep class com.taobao.** &#123;*;&#125;-keep class org.android.** &#123;*;&#125;-keep class anet.channel.** &#123;*;&#125;-keep class com.umeng.** &#123;*;&#125;-keep class com.xiaomi.** &#123;*;&#125;-keep class com.huawei.** &#123;*;&#125;-keep class org.apache.thrift.** &#123;*;&#125;-keep class com.alibaba.sdk.android.**&#123;*;&#125;-keep class com.ut.**&#123;*;&#125;-keep class com.ta.**&#123;*;&#125;-keep public class **.R$*&#123; public static final int *;&#125; #（可选）避免Log打印输出-assumenosideeffects class android.util.Log &#123; public static *** v(...); public static *** d(...); public static *** i(...); public static *** w(...); &#125; #-------------忽略警告----------------ignorewarnings 打包没要密钥文件，就新建一个，如图]]></content>
  </entry>
  <entry>
    <title><![CDATA[TextView实现跑马灯效果]]></title>
    <url>%2F2017%2F08%2F08%2FTextView%E5%AE%9E%E7%8E%B0%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1、单个TextView实现跑马灯效果在这里我们只需设置xml文件就能实现效果。 12345678910&lt;club.zhanyan.yangjie.marqueetextviewdemo.MarqueeTextView android:id="@+id/textViewId" android:layout_width="wrap_content" android:layout_height="wrap_content" android:ellipsize="marquee" //设置文字超过控件宽度时的显示方式 android:focusable="true" //设置是否获取焦点 android:focusableInTouchMode="true" //设置是否在触摸模式下获得焦点 android:marqueeRepeatLimit="marquee_forever"//设置滚动次数，marquee_forever为无限次 android:singleLine="true" //设置文本单行显示 android:text="我是一个长的TextView，我是一个长的TextView，我是一个长的TextView。" /&gt; 2、多个TextView实现跑马灯效果如果设置多个TextView的跑马灯效果，就需要为多个TextView设置焦点。而默认情况下，是只能一个TextView获取焦点的。所以，在这里我们需要强制设置焦点。 我们以两个TextView为例： 首先，我们创建一个类继承自TextView类，并且重写MarqueeTextView类所有的构造方法，并且重写isFocused()方法，返回值为true，并且将布局文件中的TextView控件改成我们自定义的类，就可以实现多个TextView的跑马灯效果了。 下面是代码： xml代码：1234567891011121314151617181920&lt;club.zhanyan.yangjie.marqueetextviewdemo.MarqueeTextView android:id="@+id/textViewId" android:layout_width="wrap_content" android:layout_height="wrap_content" android:ellipsize="marquee" android:focusable="true" android:focusableInTouchMode="true" android:marqueeRepeatLimit="marquee_forever" android:singleLine="true" android:text="我是一个长的TextView，我是一个长的TextView，我是一个长的TextView。" /&gt;&lt;club.zhanyan.yangjie.marqueetextviewdemo.MarqueeTextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/textViewId" android:ellipsize="marquee" android:focusable="true" android:focusableInTouchMode="true" android:singleLine="true" android:text="我是一个长的TextView，我是一个长的TextView，我是一个长的TextView。" /&gt; Java代码：12345678910111213141516171819package club.zhanyan.yangjie.marqueetextviewdemo;import android.content.Context;import android.util.AttributeSet;import android.widget.TextView;public class MarqueeTextView extends TextView&#123; public MarqueeTextView(Context context) &#123; supe(context); &#125; public MarqueeTextView(Context context, AttributeSet attrs) &#123; supe(context, attrs); &#125; public MarqueeTextView(Context context, AttributeSet attrs, defStyleAttr) &#123; supe(context, attrs, defStyleAttr); &#125; @override public boolean isFocused() &#123; return true; &#125;&#125; 附：ellipsize的属性: 1234android:ellipsize=”start” //省略号显示在开头 "...leng" android:ellipsize=”end” //省略号显示在结尾 "gao..." android:ellipsize=”middle” //省略号显示在中间 "ga..eng" android:ellipsize=”marquee” //以横向滚动的方式显示(必须在获得当前焦点时) TextView 1android:lines=&quot;1&quot; //单行显示 EditText 12android:inputType=&quot;textMultiLine&quot; //多行显示android:minLines=&quot;&quot; //最小显示行数]]></content>
  </entry>
</search>
